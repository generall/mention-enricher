// Generated by the Scala Plugin for the Protocol Buffer Compiler.
// Do not edit!
//
// Protofile syntax: PROTO2

package ml.generall.sentence



/** Sentence object. 
  *
  * @param sent
  *   Complete sentence text
  *   Required
  * @param mentions
  *   Mentions
  * @param parserName
  *   Name of sentence parser: CoreNLP, OpenNLP e.t.c
  *   Required
  * @param parseResult
  *   Result of string parsing
  */
@SerialVersionUID(0L)
final case class Sentente(
    sent: scala.Option[String] = None,
    mentions: scala.collection.Seq[ml.generall.sentence.Mention] = Nil,
    parserName: scala.Option[String] = None,
    parseResult: scala.collection.Seq[ml.generall.sentence.Token] = Nil
    ) extends com.trueaccord.scalapb.GeneratedMessage with com.trueaccord.scalapb.Message[Sentente] with com.trueaccord.lenses.Updatable[Sentente] {
    @transient
    private[this] var __serializedSizeCachedValue: Int = 0
    private[this] def __computeSerializedValue(): Int = {
      var __size = 0
      if (sent.isDefined) { __size += com.google.protobuf.CodedOutputStream.computeStringSize(1, sent.get) }
      mentions.foreach(mentions => __size += 1 + com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(mentions.serializedSize) + mentions.serializedSize)
      if (parserName.isDefined) { __size += com.google.protobuf.CodedOutputStream.computeStringSize(3, parserName.get) }
      parseResult.foreach(parseResult => __size += 1 + com.google.protobuf.CodedOutputStream.computeUInt32SizeNoTag(parseResult.serializedSize) + parseResult.serializedSize)
      __size
    }
    final override def serializedSize: Int = {
      var read = __serializedSizeCachedValue
      if (read == 0) {
        read = __computeSerializedValue()
        __serializedSizeCachedValue = read
      }
      read
    }
    def writeTo(`_output__`: com.google.protobuf.CodedOutputStream): Unit = {
      sent.foreach { __v =>
        _output__.writeString(1, __v)
      };
      mentions.foreach { __v =>
        _output__.writeTag(2, 2)
        _output__.writeUInt32NoTag(__v.serializedSize)
        __v.writeTo(_output__)
      };
      parserName.foreach { __v =>
        _output__.writeString(3, __v)
      };
      parseResult.foreach { __v =>
        _output__.writeTag(4, 2)
        _output__.writeUInt32NoTag(__v.serializedSize)
        __v.writeTo(_output__)
      };
    }
    def mergeFrom(`_input__`: com.google.protobuf.CodedInputStream): ml.generall.sentence.Sentente = {
      var __sent = this.sent
      val __mentions = (scala.collection.immutable.Vector.newBuilder[ml.generall.sentence.Mention] ++= this.mentions)
      var __parserName = this.parserName
      val __parseResult = (scala.collection.immutable.Vector.newBuilder[ml.generall.sentence.Token] ++= this.parseResult)
      var _done__ = false
      while (!_done__) {
        val _tag__ = _input__.readTag()
        _tag__ match {
          case 0 => _done__ = true
          case 10 =>
            __sent = Some(_input__.readString())
          case 18 =>
            __mentions += com.trueaccord.scalapb.LiteParser.readMessage(_input__, ml.generall.sentence.Mention.defaultInstance)
          case 26 =>
            __parserName = Some(_input__.readString())
          case 34 =>
            __parseResult += com.trueaccord.scalapb.LiteParser.readMessage(_input__, ml.generall.sentence.Token.defaultInstance)
          case tag => _input__.skipField(tag)
        }
      }
      ml.generall.sentence.Sentente(
          sent = __sent,
          mentions = __mentions.result(),
          parserName = __parserName,
          parseResult = __parseResult.result()
      )
    }
    def getSent: String = sent.getOrElse("")
    def clearSent: Sentente = copy(sent = None)
    def withSent(__v: String): Sentente = copy(sent = Some(__v))
    def clearMentions = copy(mentions = scala.collection.Seq.empty)
    def addMentions(__vs: ml.generall.sentence.Mention*): Sentente = addAllMentions(__vs)
    def addAllMentions(__vs: TraversableOnce[ml.generall.sentence.Mention]): Sentente = copy(mentions = mentions ++ __vs)
    def withMentions(__v: scala.collection.Seq[ml.generall.sentence.Mention]): Sentente = copy(mentions = __v)
    def getParserName: String = parserName.getOrElse("")
    def clearParserName: Sentente = copy(parserName = None)
    def withParserName(__v: String): Sentente = copy(parserName = Some(__v))
    def clearParseResult = copy(parseResult = scala.collection.Seq.empty)
    def addParseResult(__vs: ml.generall.sentence.Token*): Sentente = addAllParseResult(__vs)
    def addAllParseResult(__vs: TraversableOnce[ml.generall.sentence.Token]): Sentente = copy(parseResult = parseResult ++ __vs)
    def withParseResult(__v: scala.collection.Seq[ml.generall.sentence.Token]): Sentente = copy(parseResult = __v)
    def getField(__field: com.google.protobuf.Descriptors.FieldDescriptor): scala.Any = {
      __field.getNumber match {
        case 1 => sent.getOrElse(null)
        case 2 => mentions
        case 3 => parserName.getOrElse(null)
        case 4 => parseResult
      }
    }
    override def toString: String = com.trueaccord.scalapb.TextFormat.printToUnicodeString(this)
    def companion = ml.generall.sentence.Sentente
}

object Sentente extends com.trueaccord.scalapb.GeneratedMessageCompanion[ml.generall.sentence.Sentente] {
  implicit def messageCompanion: com.trueaccord.scalapb.GeneratedMessageCompanion[ml.generall.sentence.Sentente] = this
  def fromFieldsMap(__fieldsMap: scala.collection.immutable.Map[com.google.protobuf.Descriptors.FieldDescriptor, scala.Any]): ml.generall.sentence.Sentente = {
    require(__fieldsMap.keys.forall(_.getContainingType() == descriptor), "FieldDescriptor does not match message type.")
    val __fields = descriptor.getFields
    ml.generall.sentence.Sentente(
      __fieldsMap.get(__fields.get(0)).asInstanceOf[scala.Option[String]],
      __fieldsMap.getOrElse(__fields.get(1), Nil).asInstanceOf[scala.collection.Seq[ml.generall.sentence.Mention]],
      __fieldsMap.get(__fields.get(2)).asInstanceOf[scala.Option[String]],
      __fieldsMap.getOrElse(__fields.get(3), Nil).asInstanceOf[scala.collection.Seq[ml.generall.sentence.Token]]
    )
  }
  def descriptor: com.google.protobuf.Descriptors.Descriptor = SentenceProto.descriptor.getMessageTypes.get(6)
  def messageCompanionForField(__field: com.google.protobuf.Descriptors.FieldDescriptor): com.trueaccord.scalapb.GeneratedMessageCompanion[_] = {
    require(__field.getContainingType() == descriptor, "FieldDescriptor does not match message type.")
    var __out: com.trueaccord.scalapb.GeneratedMessageCompanion[_] = null
    __field.getNumber match {
      case 2 => __out = ml.generall.sentence.Mention
      case 4 => __out = ml.generall.sentence.Token
    }
  __out
  }
  def enumCompanionForField(__field: com.google.protobuf.Descriptors.FieldDescriptor): com.trueaccord.scalapb.GeneratedEnumCompanion[_] = throw new MatchError(__field)
  lazy val defaultInstance = ml.generall.sentence.Sentente(
  )
  implicit class SententeLens[UpperPB](_l: com.trueaccord.lenses.Lens[UpperPB, ml.generall.sentence.Sentente]) extends com.trueaccord.lenses.ObjectLens[UpperPB, ml.generall.sentence.Sentente](_l) {
    def sent: com.trueaccord.lenses.Lens[UpperPB, String] = field(_.getSent)((c_, f_) => c_.copy(sent = Some(f_)))
    def optionalSent: com.trueaccord.lenses.Lens[UpperPB, scala.Option[String]] = field(_.sent)((c_, f_) => c_.copy(sent = f_))
    def mentions: com.trueaccord.lenses.Lens[UpperPB, scala.collection.Seq[ml.generall.sentence.Mention]] = field(_.mentions)((c_, f_) => c_.copy(mentions = f_))
    def parserName: com.trueaccord.lenses.Lens[UpperPB, String] = field(_.getParserName)((c_, f_) => c_.copy(parserName = Some(f_)))
    def optionalParserName: com.trueaccord.lenses.Lens[UpperPB, scala.Option[String]] = field(_.parserName)((c_, f_) => c_.copy(parserName = f_))
    def parseResult: com.trueaccord.lenses.Lens[UpperPB, scala.collection.Seq[ml.generall.sentence.Token]] = field(_.parseResult)((c_, f_) => c_.copy(parseResult = f_))
  }
  final val SENT_FIELD_NUMBER = 1
  final val MENTIONS_FIELD_NUMBER = 2
  final val PARSER_NAME_FIELD_NUMBER = 3
  final val PARSE_RESULT_FIELD_NUMBER = 4
}
